{"ast":null,"code":"'use strict';\n\nvar invariant = require('../../vendor/invariant'),\n    makeService = require('../make_service'),\n    constants = require('../constants');\n\nvar MapboxGeocoding = makeService('MapboxGeocoding');\nvar REVERSE_GEOCODING_PRECISION = 5;\nvar FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;\n\nfunction roundTo(value, places) {\n  var mult = Math.pow(10, places);\n  return Math.round(value * mult) / mult;\n}\n/**\r\n * Search for a location with a string, using the\r\n * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\r\n *\r\n * The `query` parmeter can be an array of strings only if batch geocoding\r\n * is used by specifying `mapbox.places-permanent` as the `dataset` option.\r\n *\r\n * @param {string|Array<string>} query desired location\r\n * @param {Object} [options={}] additional options meant to tune\r\n * the request\r\n * @param {Object} options.proximity a proximity argument: this is\r\n * a geographical point given as an object with latitude and longitude\r\n * properties. Search results closer to this point will be given\r\n * higher priority.\r\n * @param {Array} options.bbox a bounding box argument: this is\r\n * a bounding box given as an array in the format [minX, minY, maxX, maxY].\r\n * Search results will be limited to the bounding box.\r\n * @param {string} options.types a comma seperated list of types that filter\r\n * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type\r\n * for available types.\r\n * @param {number=5} options.limit is the maximum number of results to return, between 1 and 10 inclusive.\r\n * Some very specific queries may return fewer results than the limit.\r\n * @param {string} options.country a comma separated list of country codes to\r\n * limit results to specified country or countries.\r\n * @param {boolean=true} options.autocomplete whether to include results that include\r\n * the query only as a prefix. This is useful for UIs where users type\r\n * values, but if you have complete addresses as input, you'll want to turn it off\r\n * @param {string} [options.dataset=mapbox.places] the desired data to be\r\n * geocoded against. The default, mapbox.places, does not permit unlimited\r\n * caching. `mapbox.places-permanent` is available on request and does\r\n * permit permanent caching.\r\n * @param {Function} callback called with (err, results)\r\n * @returns {undefined} nothing, calls callback\r\n * @memberof MapboxClient\r\n * @example\r\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\r\n * mapboxClient.geocodeForward('Paris, France', function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n * // using the proximity option to weight results closer to texas\r\n * mapboxClient.geocodeForward('Paris, France', {\r\n *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }\r\n * }, function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n * // using the bbox option to limit results to a portion of Washington, D.C.\r\n * mapboxClient.geocodeForward('Starbucks', {\r\n *   bbox: [-77.083056,38.908611,-76.997778,38.959167]\r\n * }, function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n */\n\n\nMapboxGeocoding.prototype.geocodeForward = function (query, options, callback) {\n  // permit the options argument to be omitted\n  if (callback === undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } // typecheck arguments\n\n\n  if (Array.isArray(query)) {\n    if (options.dataset !== 'mapbox.places-permanent') {\n      throw new Error('Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details');\n    } else {\n      query = query.join(';');\n    }\n  }\n\n  invariant(typeof query === 'string', 'query must be a string');\n  invariant(typeof options === 'object', 'options must be an object');\n  var queryOptions = {\n    query: query,\n    dataset: 'mapbox.places'\n  };\n  var autocomplete = true;\n  var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;\n\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.proximity) {\n    invariant(typeof options.proximity.latitude === 'number' && typeof options.proximity.longitude === 'number', 'proximity must be an object with numeric latitude & longitude properties');\n    queryOptions.proximity = roundTo(options.proximity.longitude, precision) + ',' + roundTo(options.proximity.latitude, precision);\n  }\n\n  if (options.bbox) {\n    invariant(typeof options.bbox[0] === 'number' && typeof options.bbox[1] === 'number' && typeof options.bbox[2] === 'number' && typeof options.bbox[3] === 'number' && options.bbox.length === 4, 'bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]');\n    queryOptions.bbox = options.bbox[0] + \",\" + options.bbox[1] + \",\" + options.bbox[2] + \",\" + options.bbox[3];\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit must be a number');\n    queryOptions.limit = options.limit;\n  }\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  if (options.country) {\n    invariant(typeof options.country === 'string', 'country option must be string');\n    queryOptions.country = options.country;\n  }\n\n  if (options.types) {\n    invariant(typeof options.types === 'string', 'types option must be string');\n    queryOptions.types = options.types;\n  }\n\n  if (typeof options.autocomplete === 'boolean') {\n    invariant(typeof options.autocomplete === 'boolean', 'autocomplete must be a boolean');\n    queryOptions.autocomplete = options.autocomplete;\n  }\n\n  return this.client({\n    path: constants.API_GEOCODING_FORWARD,\n    params: queryOptions,\n    callback: callback\n  });\n};\n/**\r\n * Given a location, determine what geographical features are located\r\n * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\r\n *\r\n * @param {Object} location the geographical point to search\r\n * @param {number} location.latitude decimal degrees latitude, in range -90 to 90\r\n * @param {number} location.longitude decimal degrees longitude, in range -180 to 180\r\n * @param {Object} [options={}] additional options meant to tune\r\n * the request.\r\n * @param {string} options.types a comma seperated list of types that filter\r\n * results to match those specified. See \r\n * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location\r\n * for available types.\r\n * @param {number=1} options.limit is the maximum number of results to return, between 1 and 5\r\n * inclusive. Requires a single options.types to be specified (see example).\r\n * @param {string} [options.dataset=mapbox.places] the desired data to be\r\n * geocoded against. The default, mapbox.places, does not permit unlimited\r\n * caching. `mapbox.places-permanent` is available on request and does\r\n * permit permanent caching.\r\n * @param {Function} callback called with (err, results)\r\n * @returns {undefined} nothing, calls callback\r\n * @example\r\n * var mapboxClient = new MapboxGeocoding('ACCESSTOKEN');\r\n * mapboxClient.geocodeReverse(\r\n *   { latitude: 33.6875431, longitude: -95.4431142 },\r\n *   function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n * @example\r\n * var mapboxClient = new MapboxGeocoding('ACCESSTOKEN');\r\n * mapboxClient.geocodeReverse(\r\n *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: address, limit: 3 } },\r\n *   function(err, res) {\r\n *   // res is a GeoJSON document with up to 3 geocoding matches\r\n * });\r\n */\n\n\nMapboxGeocoding.prototype.geocodeReverse = function (location, options, callback) {\n  // permit the options argument to be omitted\n  if (callback === undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } // typecheck arguments\n\n\n  invariant(typeof location === 'object', 'location must be an object');\n  invariant(typeof options === 'object', 'options must be an object');\n  invariant(typeof location.latitude === 'number' && typeof location.longitude === 'number', 'location must be an object with numeric latitude & longitude properties');\n  var queryOptions = {\n    dataset: 'mapbox.places'\n  };\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  var precision = REVERSE_GEOCODING_PRECISION;\n\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.types) {\n    invariant(typeof options.types === 'string', 'types option must be string');\n    queryOptions.types = options.types;\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit option must be a number');\n    invariant(options.types.split(',').length === 1, 'a single type must be specified to use the limit option');\n    queryOptions.limit = options.limit;\n  }\n\n  queryOptions.longitude = roundTo(location.longitude, precision);\n  queryOptions.latitude = roundTo(location.latitude, precision);\n  return this.client({\n    path: constants.API_GEOCODING_REVERSE,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\nmodule.exports = MapboxGeocoding;","map":{"version":3,"sources":["C:/Users/Fabricien/Documents/Projet/Touriste/client/node_modules/mapbox/lib/services/geocoding.js"],"names":["invariant","require","makeService","constants","MapboxGeocoding","REVERSE_GEOCODING_PRECISION","FORWARD_GEOCODING_PROXIMITY_PRECISION","roundTo","value","places","mult","Math","pow","round","prototype","geocodeForward","query","options","callback","undefined","Array","isArray","dataset","Error","join","queryOptions","autocomplete","precision","proximity","latitude","longitude","bbox","length","limit","country","types","client","path","API_GEOCODING_FORWARD","params","geocodeReverse","location","split","API_GEOCODING_REVERSE","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar invariant = require('../../vendor/invariant'),\r\n  makeService = require('../make_service'),\r\n  constants = require('../constants');\r\n\r\nvar MapboxGeocoding = makeService('MapboxGeocoding');\r\n\r\nvar REVERSE_GEOCODING_PRECISION = 5;\r\nvar FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;\r\n\r\nfunction roundTo(value, places) {\r\n  var mult = Math.pow(10, places);\r\n  return Math.round(value * mult) / mult;\r\n}\r\n\r\n/**\r\n * Search for a location with a string, using the\r\n * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\r\n *\r\n * The `query` parmeter can be an array of strings only if batch geocoding\r\n * is used by specifying `mapbox.places-permanent` as the `dataset` option.\r\n *\r\n * @param {string|Array<string>} query desired location\r\n * @param {Object} [options={}] additional options meant to tune\r\n * the request\r\n * @param {Object} options.proximity a proximity argument: this is\r\n * a geographical point given as an object with latitude and longitude\r\n * properties. Search results closer to this point will be given\r\n * higher priority.\r\n * @param {Array} options.bbox a bounding box argument: this is\r\n * a bounding box given as an array in the format [minX, minY, maxX, maxY].\r\n * Search results will be limited to the bounding box.\r\n * @param {string} options.types a comma seperated list of types that filter\r\n * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type\r\n * for available types.\r\n * @param {number=5} options.limit is the maximum number of results to return, between 1 and 10 inclusive.\r\n * Some very specific queries may return fewer results than the limit.\r\n * @param {string} options.country a comma separated list of country codes to\r\n * limit results to specified country or countries.\r\n * @param {boolean=true} options.autocomplete whether to include results that include\r\n * the query only as a prefix. This is useful for UIs where users type\r\n * values, but if you have complete addresses as input, you'll want to turn it off\r\n * @param {string} [options.dataset=mapbox.places] the desired data to be\r\n * geocoded against. The default, mapbox.places, does not permit unlimited\r\n * caching. `mapbox.places-permanent` is available on request and does\r\n * permit permanent caching.\r\n * @param {Function} callback called with (err, results)\r\n * @returns {undefined} nothing, calls callback\r\n * @memberof MapboxClient\r\n * @example\r\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\r\n * mapboxClient.geocodeForward('Paris, France', function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n * // using the proximity option to weight results closer to texas\r\n * mapboxClient.geocodeForward('Paris, France', {\r\n *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }\r\n * }, function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n * // using the bbox option to limit results to a portion of Washington, D.C.\r\n * mapboxClient.geocodeForward('Starbucks', {\r\n *   bbox: [-77.083056,38.908611,-76.997778,38.959167]\r\n * }, function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n */\r\nMapboxGeocoding.prototype.geocodeForward = function(query, options, callback) {\r\n\r\n  // permit the options argument to be omitted\r\n  if (callback === undefined && typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  // typecheck arguments\r\n  if (Array.isArray(query)) {\r\n    if (options.dataset !== 'mapbox.places-permanent') {\r\n      throw new Error('Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details')\r\n    } else {\r\n      query = query.join(';');\r\n    }\r\n  }\r\n  invariant(typeof query === 'string', 'query must be a string');\r\n  invariant(typeof options === 'object', 'options must be an object');\r\n\r\n  var queryOptions = {\r\n    query: query,\r\n    dataset: 'mapbox.places'\r\n  };\r\n\r\n  var autocomplete = true;\r\n  var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;\r\n  if (options.precision) {\r\n    invariant(typeof options.precision === 'number', 'precision option must be number');\r\n    precision = options.precision;\r\n  }\r\n\r\n  if (options.proximity) {\r\n    invariant(typeof options.proximity.latitude === 'number' &&\r\n      typeof options.proximity.longitude === 'number',\r\n      'proximity must be an object with numeric latitude & longitude properties');\r\n    queryOptions.proximity = roundTo(options.proximity.longitude, precision) + ',' + roundTo(options.proximity.latitude, precision);\r\n  }\r\n\r\n  if (options.bbox) {\r\n    invariant(typeof options.bbox[0] === 'number' &&\r\n      typeof options.bbox[1] === 'number' &&\r\n      typeof options.bbox[2] === 'number' &&\r\n      typeof options.bbox[3] === 'number' &&\r\n      options.bbox.length === 4,\r\n      'bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]');\r\n    queryOptions.bbox = options.bbox[0] + \",\" + options.bbox[1] + \",\" + options.bbox[2] + \",\" + options.bbox[3];\r\n  }\r\n\r\n  if (options.limit) {\r\n    invariant(typeof options.limit === 'number',\r\n      'limit must be a number');\r\n    queryOptions.limit = options.limit;\r\n  }\r\n\r\n  if (options.dataset) {\r\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\r\n    queryOptions.dataset = options.dataset;\r\n  }\r\n\r\n  if (options.country) {\r\n    invariant(typeof options.country === 'string', 'country option must be string');\r\n    queryOptions.country = options.country;\r\n  }\r\n\r\n  if (options.types) {\r\n    invariant(typeof options.types === 'string', 'types option must be string');\r\n    queryOptions.types = options.types;\r\n  }\r\n\r\n  if (typeof options.autocomplete === 'boolean') {\r\n    invariant(typeof options.autocomplete === 'boolean', 'autocomplete must be a boolean');\r\n    queryOptions.autocomplete = options.autocomplete;\r\n  }\r\n\r\n  return this.client({\r\n    path: constants.API_GEOCODING_FORWARD,\r\n    params: queryOptions,\r\n    callback: callback\r\n  });\r\n};\r\n\r\n/**\r\n * Given a location, determine what geographical features are located\r\n * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\r\n *\r\n * @param {Object} location the geographical point to search\r\n * @param {number} location.latitude decimal degrees latitude, in range -90 to 90\r\n * @param {number} location.longitude decimal degrees longitude, in range -180 to 180\r\n * @param {Object} [options={}] additional options meant to tune\r\n * the request.\r\n * @param {string} options.types a comma seperated list of types that filter\r\n * results to match those specified. See \r\n * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location\r\n * for available types.\r\n * @param {number=1} options.limit is the maximum number of results to return, between 1 and 5\r\n * inclusive. Requires a single options.types to be specified (see example).\r\n * @param {string} [options.dataset=mapbox.places] the desired data to be\r\n * geocoded against. The default, mapbox.places, does not permit unlimited\r\n * caching. `mapbox.places-permanent` is available on request and does\r\n * permit permanent caching.\r\n * @param {Function} callback called with (err, results)\r\n * @returns {undefined} nothing, calls callback\r\n * @example\r\n * var mapboxClient = new MapboxGeocoding('ACCESSTOKEN');\r\n * mapboxClient.geocodeReverse(\r\n *   { latitude: 33.6875431, longitude: -95.4431142 },\r\n *   function(err, res) {\r\n *   // res is a GeoJSON document with geocoding matches\r\n * });\r\n * @example\r\n * var mapboxClient = new MapboxGeocoding('ACCESSTOKEN');\r\n * mapboxClient.geocodeReverse(\r\n *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: address, limit: 3 } },\r\n *   function(err, res) {\r\n *   // res is a GeoJSON document with up to 3 geocoding matches\r\n * });\r\n */\r\nMapboxGeocoding.prototype.geocodeReverse = function(location, options, callback) {\r\n\r\n  // permit the options argument to be omitted\r\n  if (callback === undefined && typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  // typecheck arguments\r\n  invariant(typeof location === 'object', 'location must be an object');\r\n  invariant(typeof options === 'object', 'options must be an object');\r\n\r\n  invariant(typeof location.latitude === 'number' &&\r\n    typeof location.longitude === 'number',\r\n    'location must be an object with numeric latitude & longitude properties');\r\n\r\n  var queryOptions = {\r\n    dataset: 'mapbox.places'\r\n  };\r\n\r\n  if (options.dataset) {\r\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\r\n    queryOptions.dataset = options.dataset;\r\n  }\r\n\r\n  var precision = REVERSE_GEOCODING_PRECISION;\r\n  if (options.precision) {\r\n    invariant(typeof options.precision === 'number', 'precision option must be number');\r\n    precision = options.precision;\r\n  }\r\n\r\n  if (options.types) {\r\n    invariant(typeof options.types === 'string', 'types option must be string');\r\n    queryOptions.types = options.types;\r\n  }\r\n\r\n  if (options.limit) {\r\n    invariant(typeof options.limit === 'number', 'limit option must be a number');\r\n    invariant(options.types.split(',').length === 1, 'a single type must be specified to use the limit option');\r\n    queryOptions.limit = options.limit;\r\n  }\r\n\r\n  queryOptions.longitude = roundTo(location.longitude, precision);\r\n  queryOptions.latitude = roundTo(location.latitude, precision);\r\n\r\n  return this.client({\r\n    path: constants.API_GEOCODING_REVERSE,\r\n    params: queryOptions,\r\n    callback: callback\r\n  });\r\n};\r\n\r\nmodule.exports = MapboxGeocoding;\r\n"]},"metadata":{},"sourceType":"script"}