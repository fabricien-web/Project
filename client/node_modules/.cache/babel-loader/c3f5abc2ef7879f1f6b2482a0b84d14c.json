{"ast":null,"code":"/*\r\n * Copyright 2012-2016 the original author or authors\r\n * @license MIT, see LICENSE.txt for details\r\n *\r\n * @author Scott Andrews\r\n */\n'use strict';\n\nvar interceptor, mime, registry, noopConverter, missingConverter, attempt;\ninterceptor = require('../interceptor');\nmime = require('../mime');\nregistry = require('../mime/registry');\nattempt = require('../util/attempt');\nnoopConverter = {\n  read: function (obj) {\n    return obj;\n  },\n  write: function (obj) {\n    return obj;\n  }\n};\nmissingConverter = {\n  read: function () {\n    throw 'No read method found on converter';\n  },\n  write: function () {\n    throw 'No write method found on converter';\n  }\n};\n/**\r\n * MIME type support for request and response entities.  Entities are\r\n * (de)serialized using the converter for the MIME type.\r\n *\r\n * Request entities are converted using the desired converter and the\r\n * 'Accept' request header prefers this MIME.\r\n *\r\n * Response entities are converted based on the Content-Type response header.\r\n *\r\n * @param {Client} [client] client to wrap\r\n * @param {string} [config.mime='text/plain'] MIME type to encode the request\r\n *   entity\r\n * @param {string} [config.accept] Accept header for the request\r\n * @param {Client} [config.client=<request.originator>] client passed to the\r\n *   converter, defaults to the client originating the request\r\n * @param {Registry} [config.registry] MIME registry, defaults to the root\r\n *   registry\r\n * @param {boolean} [config.permissive] Allow an unkown request MIME type\r\n *\r\n * @returns {Client}\r\n */\n\nmodule.exports = interceptor({\n  init: function (config) {\n    config.registry = config.registry || registry;\n    return config;\n  },\n  request: function (request, config) {\n    var type, headers;\n    headers = request.headers || (request.headers = {});\n    type = mime.parse(headers['Content-Type'] || config.mime || 'text/plain');\n    headers.Accept = headers.Accept || config.accept || type.raw + ', application/json;q=0.8, text/plain;q=0.5, */*;q=0.2';\n\n    if (!('entity' in request)) {\n      return request;\n    }\n\n    headers['Content-Type'] = type.raw;\n    return config.registry.lookup(type)['catch'](function () {\n      // failed to resolve converter\n      if (config.permissive) {\n        return noopConverter;\n      }\n\n      throw 'mime-unknown';\n    }).then(function (converter) {\n      var client = config.client || request.originator,\n          write = converter.write || missingConverter.write;\n      return attempt(write.bind(void 0, request.entity, {\n        client: client,\n        request: request,\n        mime: type,\n        registry: config.registry\n      }))['catch'](function () {\n        throw 'mime-serialization';\n      }).then(function (entity) {\n        request.entity = entity;\n        return request;\n      });\n    });\n  },\n  response: function (response, config) {\n    if (!(response.headers && response.headers['Content-Type'] && response.entity)) {\n      return response;\n    }\n\n    var type = mime.parse(response.headers['Content-Type']);\n    return config.registry.lookup(type)['catch'](function () {\n      return noopConverter;\n    }).then(function (converter) {\n      var client = config.client || response.request && response.request.originator,\n          read = converter.read || missingConverter.read;\n      return attempt(read.bind(void 0, response.entity, {\n        client: client,\n        response: response,\n        mime: type,\n        registry: config.registry\n      }))['catch'](function (e) {\n        response.error = 'mime-deserialization';\n        response.cause = e;\n        throw response;\n      }).then(function (entity) {\n        response.entity = entity;\n        return response;\n      });\n    });\n  }\n});","map":{"version":3,"sources":["C:/Users/Fabricien/Documents/Projet/Touriste/client/node_modules/rest/interceptor/mime.js"],"names":["interceptor","mime","registry","noopConverter","missingConverter","attempt","require","read","obj","write","module","exports","init","config","request","type","headers","parse","Accept","accept","raw","lookup","permissive","then","converter","client","originator","bind","entity","response","e","error","cause"],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2012-2016 the original author or authors\r\n * @license MIT, see LICENSE.txt for details\r\n *\r\n * @author Scott Andrews\r\n */\r\n\r\n'use strict';\r\n\r\nvar interceptor, mime, registry, noopConverter, missingConverter, attempt;\r\n\r\ninterceptor = require('../interceptor');\r\nmime = require('../mime');\r\nregistry = require('../mime/registry');\r\nattempt = require('../util/attempt');\r\n\r\nnoopConverter = {\r\n\tread: function (obj) { return obj; },\r\n\twrite: function (obj) { return obj; }\r\n};\r\n\r\nmissingConverter = {\r\n\tread: function () { throw 'No read method found on converter'; },\r\n\twrite: function () { throw 'No write method found on converter'; }\r\n};\r\n\r\n/**\r\n * MIME type support for request and response entities.  Entities are\r\n * (de)serialized using the converter for the MIME type.\r\n *\r\n * Request entities are converted using the desired converter and the\r\n * 'Accept' request header prefers this MIME.\r\n *\r\n * Response entities are converted based on the Content-Type response header.\r\n *\r\n * @param {Client} [client] client to wrap\r\n * @param {string} [config.mime='text/plain'] MIME type to encode the request\r\n *   entity\r\n * @param {string} [config.accept] Accept header for the request\r\n * @param {Client} [config.client=<request.originator>] client passed to the\r\n *   converter, defaults to the client originating the request\r\n * @param {Registry} [config.registry] MIME registry, defaults to the root\r\n *   registry\r\n * @param {boolean} [config.permissive] Allow an unkown request MIME type\r\n *\r\n * @returns {Client}\r\n */\r\nmodule.exports = interceptor({\r\n\tinit: function (config) {\r\n\t\tconfig.registry = config.registry || registry;\r\n\t\treturn config;\r\n\t},\r\n\trequest: function (request, config) {\r\n\t\tvar type, headers;\r\n\r\n\t\theaders = request.headers || (request.headers = {});\r\n\t\ttype = mime.parse(headers['Content-Type'] || config.mime || 'text/plain');\r\n\t\theaders.Accept = headers.Accept || config.accept || type.raw + ', application/json;q=0.8, text/plain;q=0.5, */*;q=0.2';\r\n\r\n\t\tif (!('entity' in request)) {\r\n\t\t\treturn request;\r\n\t\t}\r\n\r\n\t\theaders['Content-Type'] = type.raw;\r\n\r\n\t\treturn config.registry.lookup(type)['catch'](function () {\r\n\t\t\t// failed to resolve converter\r\n\t\t\tif (config.permissive) {\r\n\t\t\t\treturn noopConverter;\r\n\t\t\t}\r\n\t\t\tthrow 'mime-unknown';\r\n\t\t}).then(function (converter) {\r\n\t\t\tvar client = config.client || request.originator,\r\n\t\t\t\twrite = converter.write || missingConverter.write;\r\n\r\n\t\t\treturn attempt(write.bind(void 0, request.entity, { client: client, request: request, mime: type, registry: config.registry }))\r\n\t\t\t\t['catch'](function() {\r\n\t\t\t\t\tthrow 'mime-serialization';\r\n\t\t\t\t})\r\n\t\t\t\t.then(function(entity) {\r\n\t\t\t\t\trequest.entity = entity;\r\n\t\t\t\t\treturn request;\r\n\t\t\t\t});\r\n\t\t});\r\n\t},\r\n\tresponse: function (response, config) {\r\n\t\tif (!(response.headers && response.headers['Content-Type'] && response.entity)) {\r\n\t\t\treturn response;\r\n\t\t}\r\n\r\n\t\tvar type = mime.parse(response.headers['Content-Type']);\r\n\r\n\t\treturn config.registry.lookup(type)['catch'](function () { return noopConverter; }).then(function (converter) {\r\n\t\t\tvar client = config.client || response.request && response.request.originator,\r\n\t\t\t\tread = converter.read || missingConverter.read;\r\n\r\n\t\t\treturn attempt(read.bind(void 0, response.entity, { client: client, response: response, mime: type, registry: config.registry }))\r\n\t\t\t\t['catch'](function (e) {\r\n\t\t\t\t\tresponse.error = 'mime-deserialization';\r\n\t\t\t\t\tresponse.cause = e;\r\n\t\t\t\t\tthrow response;\r\n\t\t\t\t})\r\n\t\t\t\t.then(function (entity) {\r\n\t\t\t\t\tresponse.entity = entity;\r\n\t\t\t\t\treturn response;\r\n\t\t\t\t});\r\n\t\t});\r\n\t}\r\n});\r\n"]},"metadata":{},"sourceType":"script"}